// x86-64 processor support
// https://github.com/usbarmory/tamago
//
// Copyright (c) The TamaGo Authors. All Rights Reserved.
//
// Use of this source code is governed by the license
// that can be found in the LICENSE file.

#include "go_asm.h"
#include "textflag.h"

// Interrupt Descriptor Table
GLOBL	·idt<>(SB),RODATA,$(const_vectors*16)

DATA	·idtptr+0x00(SB)/2, $(const_vectors*16-1)	// IDT Limit
DATA	·idtptr+0x02(SB)/8, $·idt<>(SB)			// IDT Base Address
GLOBL	·idtptr(SB),RODATA,$(2+8)

// func load_idt() (idt uintptr, irqHandler uintptr)
TEXT ·load_idt(SB),$0-16
	MOVQ	$·idtptr(SB), AX
	LIDT	(AX)

	MOVQ	$·idt<>(SB), AX
	MOVQ	AX, ret+0(FP)

	// return irqHandler.abi0 pointer
	MOVQ	$·irqHandler(SB), AX
	MOVQ	AX, ret+8(FP)

	RET

// func wfi()
TEXT ·wfi(SB),$0
	// disable interrupts to avoid races while checking state
	CLI

	MOVB	·irqLock(SB), AX
	CMPB	AX, $1
	JE	done

	// wait for interrupt
	STI
	HLT
done:
	STI
	RET

TEXT ·ignoreInterrupt(SB),NOSPLIT|NOFRAME,$0
	// IRQs to ignore, used to resume halted processors, are generated by:
	//  * ·handleInterrupt to wake idle APs
	//  * CPU.LAPIC.SetTimer at timer expiration
	//  * CPU.SetAlarm with null deadline

	// save caller registers
	PUSHQ	AX

	// clear interrupt
	MOVL	$(const_LAPIC_EOI), AX
	MOVL	$0, (AX)

	// restore caller registers
	POPQ	AX

	// return to caller
	ADDQ	$8, SP
	IRETQ

TEXT ·handleInterrupt(SB),NOSPLIT|NOFRAME,$0
	// save caller registers
	PUSHQ	BX
	PUSHQ	DX
	PUSHQ	CX
	PUSHQ	AX

	// AMD64 Architecture Programmer’s Manual
	// Volume 2 - 8.9.3 Interrupt Stack Frame

	// find ISR offset from stack linking information (see irqHandler)
	MOVQ	isr-(0)(SP), AX
	SUBQ	$(const_callSize), AX
	MOVQ	AX, ·currentVector(SB)

	MOVQ	·irqHandlerG(SB), AX
	CMPQ	AX, $0
	JE	done

	MOVB	$1, ·irqHandling(SB)
	MOVB	$1, ·irqLock(SB)

	CALL	runtime·WakeG(SB)
	CMPQ	AX, $0
	JNE	done

	// wake idle APs
	MOVL	$(const_LAPIC_ICRL), AX
	MOVL	$(const_ICR_DST_REST|const_IRQ_WAKEUP), (AX)
done:
	// restore caller registers
	POPQ	AX
	POPQ	CX
	POPQ	DX
	POPQ	BX

	// return to caller
	ADDQ	$8, SP
	MOVB	$0, ·irqHandling(SB)
	IRETQ

TEXT ·handleNMI(SB),NOSPLIT|NOFRAME,$0
	// NMIs are generated by:
	//  * CPU.Task to wake up the next AP (see ·apstart)
	//  * CPU.EnableInterrupt to unmask IRQs on the BSP

	// save caller registers
	PUSHQ	AX

	// clear interrupt
	MOVL	$(const_LAPIC_EOI), AX
	MOVL	$0, (AX)

	// restore caller registers
	POPQ	AX

	// return to caller
	MOVB	$0, ·irqLock(SB)
	IRETQ
